#pragma config(Sensor, S1,     ATLAS,               sensorLowSpeed)

//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
//

void start_gyro(){
  ubyte I2Csnd[4];
  I2Csnd[0] = 3;    // Sending address, register, value.
  I2Csnd[1] = 0xD2; // I2C Address of gyro.
  ubyte I2Crec[1];        // We are looking for a single byte returned.

  //Write CTRL_REG1
  ////////////////////////////////////////////////////////////////////////////
    I2Csnd[2] = 0x20;      // Register address of CTRL_REG1
    I2Csnd[3] = 0x0F;      // Enable all axes. Disable power down.
    sendI2CMsg(S1, I2Csnd[0], 1);     // (Port 1, Message Array, Reply Size)
    wait1Msec(10);
    readI2CReply(S1, I2Crec[0], 1);  // (Port 1, Reply Array, Bytes to Read)

  //Write CTRL_REG2
  ////////////////////////////////////////////////////////////////////////////
    I2Csnd[2] = 0x21;                  // Register address of CTRL_REG2
    I2Csnd[3] = 0x00;                  // No High Pass Filter
    sendI2CMsg(S1, I2Csnd[0], 1);     // (Port 1, Message Array, Reply Size)
    wait1Msec(10);
    readI2CReply(S1, I2Crec[0], 1);   // (Port 1, Reply Array, Bytes to Read)

  //Write CTRL_REG3
  ////////////////////////////////////////////////////////////////////////////
    I2Csnd[2] = 0x22;      // Register address of CTRL_REG3
    I2Csnd[3] = 0x08;      // No interrupts.  Date ready.
    sendI2CMsg(S1, I2Csnd[0], 1);     // (Port 1, Message Array, Reply Size)
    wait1Msec(10);
    readI2CReply(S1, I2Crec[0], 1);  // (Port 1, Reply Array, Bytes to Read)

  //Write CTRL_REG4
  ////////////////////////////////////////////////////////////////////////////
    I2Csnd[2] = 0x23;      // Register address of CTRL_REG4
    I2Csnd[3] = 0x00;      // Full scale range.
    sendI2CMsg(S1, I2Csnd[0], 1);     // (Port 1, Message Array, Reply Size)
    wait1Msec(10);
    readI2CReply(S1, I2Crec[0], 1);  // (Port 1, Reply Array, Bytes to Read)

  //Write CTRL_REG5
  ////////////////////////////////////////////////////////////////////////////
    I2Csnd[2] = 0x24;      // Register address of CTRL_REG5
    I2Csnd[3] = 0x00;      // Enable all axes. Disable power down.
    sendI2CMsg(S1, I2Csnd[0], 1);     // (Port 1, Message Array, Reply Size)
    wait1Msec(10);
    readI2CReply(S1, I2Crec[0], 1);  // (Port 1, Reply Array, Bytes to Read)
}

void start_accl(){
  ubyte I2Csnd[4];
  I2Csnd[0] = 3;    // Sending address, register, value.
  I2Csnd[1] = 0x3A; // I2C Address of Accelerometer.
  ubyte I2Crec[1];        // We are looking for a single byte returned.

  //Set the Mode Control
  ////////////////////////////////////////////////////////////////////////////
    I2Csnd[2] = 0x16;       // Register address of Mode Control
    I2Csnd[3] = 0x09;       // 0x05 For 2G
                            // 0x09 For 4G
                            // 0x01 For 8G
    sendI2CMsg(S1, I2Csnd[0], 1);     // (Port 1, Message Array, Reply Size)
    wait1Msec(10);
    readI2CReply(S1, I2Crec[0], 1);  // (Port 1, Reply Array, Bytes to Read)
}

// Gyro: axis_reading gets a byte of axis reading data
ubyte gyro_axis_reading(ubyte reg){
  //ubyte ax = reg;
  ubyte I2Csnd[3];        //
  I2Csnd[0] = 2;    // Sending address, register.
  I2Csnd[1] = 0xD2; // I2C Address of gyro.
  I2Csnd[2] = reg;   // Register of the data we're requesting.

  ubyte I2Crec[1];        // We are looking for a single byte returned.

  sendI2CMsg(S1, I2Csnd[0], 1);     // (Port 1, Message Array, Reply Size)
  wait1Msec(10);
  readI2CReply(S1, I2Crec[0], 1);  // (Port 1, Reply Array, Bytes to Read)

  ubyte result = I2Crec[0];
  return result;
}

// Acell axis_reading gets a byte of axis reading data
ubyte accl_axis_reading(ubyte reg){
  ubyte I2Csnd[3];        //
  I2Csnd[0] = 2;      // Sending address, register.
  I2Csnd[1] = 0x3A;   // I2C Address of accl.
  I2Csnd[2] = reg;    // Register of the data we're requesting.

  ubyte I2Crec[1];        // We are looking for a single byte returned.

  sendI2CMsg(S1, I2Csnd[0], 1);     // (Port 1, Message Array, Reply Size)
  wait1Msec(10);
  readI2CReply(S1, I2Crec[0], 1);  // (Port 1, Reply Array, Bytes to Read)

  ubyte result = I2Crec[0];
  wait1Msec(10);
  return I2Crec[0];
}

void cal_up(){

}


task main(){
  start_gyro();      // Fire up the gyro.  Initialize it.             Only needs to be done once.
  start_accl();      // Fire up the accelerometer.  Initialize it.    Only needs to be done once.
  long x_val, y_val, z_val;      // Our assembled values.

  while (true){


      // GYROSCOPE
      // Get x axis data.
      //ubyte x_hb = gyro_axis_reading(0x29);
      //ubyte x_lb = gyro_axis_reading(0x28);
      // Get y axis data.
      //ubyte y_hb = gyro_axis_reading(0x2B);
      //ubyte y_lb = gyro_axis_reading(0x2A);
      // Get z axis data.
      //ubyte z_hb = gyro_axis_reading(0x2D);
      //ubyte z_lb = gyro_axis_reading(0x2C);

      // Compute out the values.
      //x_val = (x_lb+((long)(x_hb<<8)))/10;
      //y_val = (y_lb+((long)(y_hb<<8)))/10;
      //z_val = (z_lb+((long)(z_hb<<8)))/10;

      //nxtDisplayTextLine(5, "%i", x_val);
      //nxtDisplayTextLine(6, "%i", y_val);
      //nxtDisplayTextLine(7, "%i", z_val);

      // ACCELEROMETER
      // In this example, we'll just get the 8-bit data.  This can be extended to
      // 10 bit by going into the data sheet.

      byte x_acc = accl_axis_reading(0x06);         // Get x axis data.
      //byte y_acc = accl_axis_reading(0x07);         // Get y axis data.
      //byte z_acc = accl_axis_reading(0x08);         // Get z axis data.

      // 2g is 64 LSB/g
      // 4g is 32 LSB/g  //
      // 8g is 16 LSB/g  // Also note if 8g, must use LSB/MSB

      nxtDisplayTextLine(1, "%i", x_acc);
      //nxtDisplayTextLine(2, "%i", y_acc);
      //nxtDisplayTextLine(3, "%i", z_acc);

    wait1Msec(5);
  }
}
